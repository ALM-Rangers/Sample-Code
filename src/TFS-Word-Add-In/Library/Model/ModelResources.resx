<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DefaultNeededToCreateLayout" xml:space="preserve">
    <value>Cannot create layout {0} because the Default layout item is either empty or missing.</value>
  </data>
  <data name="FormatterEndOfImportBoilerPlate" xml:space="preserve">
    <value>End of import (added this text because the import was at the end and it can be difficult to insert text after the import, delete this text if you wish)</value>
  </data>
  <data name="FormatterStartOfImportBoilerPlate" xml:space="preserve">
    <value>Start of import (added this text because the import was at the start and it can be difficult to insert text before the import, delete this text if you wish)</value>
  </data>
  <data name="InstructionsDefaultBuildingBlock" xml:space="preserve">
    <value>Insert work item layout here. Double-click the fields you require, add any surrounding text and format the content. When formatting content make sure that formatting is done from outside the fields rather than inside, as any formatting inside the fields is lost when the field content is added.</value>
  </data>
  <data name="InstructionsPreviewBuildingBlock" xml:space="preserve">
    <value>If you want the preview to include some sample data, format this section with the desired preview. Otherwise delete this section altogether (including the Preview heading) and the preview will be the contents of the Default section.</value>
  </data>
  <data name="LayoutMissing" xml:space="preserve">
    <value>The definition of the {0} layout is missing, the document will not be refreshable</value>
  </data>
  <data name="LoadTemplateFirst" xml:space="preserve">
    <value>The template must be loaded first.</value>
  </data>
  <data name="MultipleInstancesForSameDocumentNotPermitted" xml:space="preserve">
    <value>Cannot create more than one Team Project Document for the same document.</value>
  </data>
  <data name="NoSavedWorkItems" xml:space="preserve">
    <value>Work items must be saved into the document first.</value>
  </data>
  <data name="QueryCouldNotBeParsed" xml:space="preserve">
    <value>The query could not be parsed. The query text is {0}</value>
  </data>
  <data name="QueryNotWellFormedOneHop" xml:space="preserve">
    <value>Query does not produce a well-formed direct link structure.</value>
  </data>
  <data name="QueryNotWellFormedTree" xml:space="preserve">
    <value>Query does not produce a well-formed tree.</value>
  </data>
  <data name="TeamProjectNotSet" xml:space="preserve">
    <value>Team Project has not been set.</value>
  </data>
  <data name="VerifierBookmarkOverlap" xml:space="preserve">
    <value>Bookmark for work item {1} in query {0} overlaps with bookmark for work item {3} in query {2}</value>
  </data>
  <data name="VerifierContentControlInWrongBookmark" xml:space="preserve">
    <value>Work item {1} for query {0} bookmark contains fields from work item {2}</value>
  </data>
  <data name="VerifierMappedContentControlNotInBookmark" xml:space="preserve">
    <value>Field from work item {0} is not in any bookmark</value>
  </data>
  <data name="VerifierWorkItemBookmarkMissing" xml:space="preserve">
    <value>Work item {1} bookmark is missing from the document for query {0}</value>
  </data>
  <data name="VerifierWorkItemContentMissing" xml:space="preserve">
    <value>Work item {1} bookmark is present but the work item content is missing from the document for query {0}</value>
  </data>
</root>